package koh.realm.app;

import com.google.inject.Binder;
import com.google.inject.Inject;
import com.google.inject.Scopes;
import com.google.inject.Singleton;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import koh.patterns.services.api.DependsOn;
import koh.patterns.services.api.Service;
import koh.realm.dao.api.AccountDAO;
import koh.realm.dao.api.CharacterDAO;
import koh.realm.dao.api.GameServerDAO;
import koh.realm.dao.impl.AccountDAOImpl;
import koh.realm.dao.impl.CharacterDAOImpl;
import koh.realm.dao.impl.GameServerDAOImpl;
import koh.realm.utils.Settings;
import koh.realm.utils.sql.ConnectionResult;
import koh.realm.utils.sql.ConnectionStatement;

import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;

/**
 *
 * @author Neo-Craft
 */

@DependsOn({MemoryService.class})
public class DatabaseSource implements Service {

    private final HikariConfig config;
    private HikariDataSource dataSource;

    @Inject
    public DatabaseSource(Settings settings) {
        this.config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://" + settings.getStringElement("Database.Host") + "/" + settings.getStringElement("Database.Name"));

        //config.setDataSourceClassName("com.mysql.jdbc.jdbc2.optional.MysqlDataSource");
        config.setUsername(settings.getStringElement("Database.User"));
        config.setPassword(settings.getStringElement("Database.Password"));
        config.addDataSourceProperty("cachePrepStmts", "true");
        config.addDataSourceProperty("prepStmtCacheSize", "250");
        config.addDataSourceProperty("prepStmtCacheSqlLimit", "2048");
        //config.addDataSourceProperty("dataSource.logWriter", new PrintWriter(System.out));
        config.setMaximumPoolSize(30);

        //this.dataSource = new HikariDataSource(config);
    }

    public Connection getConnectionOfPool() throws SQLException {
        return dataSource.getConnection();
    }

    public ConnectionStatement<Statement> createStatement() throws SQLException {
        Connection connection = this.getConnectionOfPool();
        return new ConnectionStatement<>(connection, connection.createStatement());
    }

    public ConnectionStatement<PreparedStatement> prepareStatement(String query) throws SQLException {
        Connection connection = this.getConnectionOfPool();
        return new ConnectionStatement<>(connection, connection.prepareStatement(query));
    }

    public ConnectionStatement<PreparedStatement> prepareStatement(String query, boolean autoGeneratedKeys) throws SQLException {
        Connection connection = this.getConnectionOfPool();
        PreparedStatement statement = connection.prepareStatement(query,
                autoGeneratedKeys ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS);
        return new ConnectionStatement<>(connection, statement);
    }

    public ConnectionResult executeQuery(String query) throws SQLException {
        Connection connection = this.getConnectionOfPool();
        Statement statement = connection.createStatement();
        statement.setQueryTimeout(300);
        return new ConnectionResult(connection, statement, statement.executeQuery(query));
    }

    public ConnectionResult executeQuery(String query, int secsTimeout) throws SQLException {
        Connection connection = this.getConnectionOfPool();
        Statement statement = connection.createStatement();
        if(secsTimeout > 0)
            statement.setQueryTimeout(secsTimeout);
        return new ConnectionResult(connection, statement, statement.executeQuery(query));
    }

    @Override
    public void start() {
        if(dataSource != null && !dataSource.isClosed())
            dataSource.close();
        this.dataSource = new HikariDataSource(config);
    }

    @Override
    public void stop() {
        if(dataSource != null)
            dataSource.close();
    }

    @Override
    public void configure(Binder binder) { }

}
